/*.$file${../src::main.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: Blinky.qm
* File:  ${../src::main.cpp}
*
* This code has been generated by QM 5.1.1 <www.state-machine.com/qm/>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*.$endhead${../src::main.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/* Some Important Points about QF (Active Object Framework)
1) Create Event Queues (array of QEvt) for the active objects.
2) Create and Initialize Active Object Control Block (QActiveCB)
3) Call QF_init( maxActive ) to initialize the Active object framework of QP-nano
  * this also calls the init funcvtion of underlying kernel.
4) Call QF_run()
  * this also calls the scheduler of the kernel and never returns
5) Call QF_tickXISR() from your application's tick ISR
*/

#include "qpn.h"
#include "Arduino.h"

/* Macros */
#define BSP_TICKS_PER_SEC           100u   /* Number of Ticks in one second */
#define LED_L                       13u

/* private function prototypes */
static void sys_tick_init( void );

/* Declare all AO classes */
/*.$declare${AOs::Blinky} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::Blinky} ..........................................................*/
typedef struct Blinky {
/* protected: */
    QActive super;
} Blinky;

/* protected: */
static QState Blinky_initial(Blinky * const me);
static QState Blinky_off(Blinky * const me);
static QState Blinky_on(Blinky * const me);
/*.$enddecl${AOs::Blinky} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*Instance of AO Classes */
Blinky AO_Blinky;

/* 1) Create Event Queues (array of QEvt) for the active objects. */
static QEvt BlinkyQueue[10u];        /* Event Queue Storage*/
/* 2) Create and Initialize Active Object Control Block (QActiveCB) */
QActiveCB const Q_ROM QF_active[] =
{
  { (QActive *)0,           (QEvt *)0,           0U                 },
  { (QActive *)&AO_Blinky,  (QEvt *)BlinkyQueue, Q_DIM(BlinkyQueue) }
};

void  setup()
{
  Serial.begin(115200);
  delay(10);

  /* 3) Call QF_init( maxActive ) to initialize the Active object framework of QP-nano*/
  QF_init( Q_DIM(QF_active) );
  /* Initialize All Active objects (constructor)*/
  QActive_ctor( &AO_Blinky.super, Q_STATE_CAST(&Blinky_initial));

  Serial.println("Program Started");
  pinMode( LED_L, OUTPUT);
}

void loop()
{
  /* 4) Call QF_run() */
  QF_run();
}


/* define all AO classes (state machine)...*/
/*.$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*. Check for the minimum required QP version */
#if (QP_VERSION < 690U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpn version 6.9.0 or higher required
#endif
/*.$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${AOs::Blinky} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::Blinky} ..........................................................*/
/*.${AOs::Blinky::SM} ......................................................*/
static QState Blinky_initial(Blinky * const me) {
    /*.${AOs::Blinky::SM::initial} */
    QActive_armX((QActive *)me, 0U, BSP_TICKS_PER_SEC/2U, BSP_TICKS_PER_SEC/2U);
    return Q_TRAN(&Blinky_off);
}
/*.${AOs::Blinky::SM::off} .................................................*/
static QState Blinky_off(Blinky * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${AOs::Blinky::SM::off} */
        case Q_ENTRY_SIG: {
            digitalWrite( LED_L, LOW);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Blinky::SM::off::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&Blinky_on);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.${AOs::Blinky::SM::on} ..................................................*/
static QState Blinky_on(Blinky * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${AOs::Blinky::SM::on} */
        case Q_ENTRY_SIG: {
            digitalWrite( LED_L, HIGH);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Blinky::SM::on::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&Blinky_off);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.$enddef${AOs::Blinky} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/


/* Timer Interrupt */
ISR(TIMER2_COMPA_vect)
{
  /* process time events for tick rate 0 */
  QF_tickXISR(0);
}

static void sys_tick_init( void )
{
  // set Timer2 in CTC mode, 1/1024 prescaler, start the timer ticking...
  TCCR2A = (1U << WGM21) | (0U << WGM20);
  TCCR2B = (1U << CS22 ) | (1U << CS21) | (1U << CS20); // 1/2^10
  ASSR  &= ~(1U << AS2);
  TIMSK2 = (1U << OCIE2A); // enable TIMER2 compare Interrupt
  TCNT2  = 0U;

  // set the output-compare register based on the desired tick frequency
  OCR2A  = (F_CPU / BSP_TICKS_PER_SEC / 1024U) - 1U;
}

/* Below functions are the callbak functions from the QP Framework*/
void QF_onStartup( void )
{
  sys_tick_init();
}

void QV_onIdle( void )
{
  /* this function called with interrupts DISABLED, and can be used to perform
     activity/task like staying in sleep mode */
}

Q_NORETURN Q_onAssert( char const Q_ROM * const module, int location )
{
  Serial.println("Assertion Failure!!");
  Serial.println((String)module);
  Serial.println(location);
  /* As per documentation it's not a good idea to do like this */
  while(1);
}