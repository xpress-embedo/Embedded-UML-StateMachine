/*.$file${HSMs::../src::ClockAlarm_SM.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: ClockAlarm.qm
* File:  ${HSMs::../src::ClockAlarm_SM.cpp}
*
* This code has been generated by QM 5.1.1 <www.state-machine.com/qm/>.
* DO NOT EDIT SECTIONS BETWEEN THE COMMENTS "$...vvv".."$end...^^^".
* All your changes in these sections will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*.$endhead${HSMs::../src::ClockAlarm_SM.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#include <Arduino.h>
#include "qpn.h"
#include "lcd.h"
#include "ClockAlarm_SM.h"

/* Some Helper macros */
#define GET_HOUR(seconds)           ( seconds/3600ul )
#define GET_MIN(seconds)            ( (seconds/60ul) % 60ul )
#define GET_SEC(seconds)            ( seconds % 60ul )
#define DIGIT1(d)       	  ( d / 10u)
#define DIGIT2(d)       	  ( d % 10u)

/*.$declare${HSMs::Clock_Alarm} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${HSMs::Clock_Alarm} ....................................................*/
typedef struct Clock_Alarm {
/* protected: */
    QHsm super;

/* private: */
    uint32_t temp_time;
    uint32_t alarm_time;
    uint8_t alarm_status;
    uint8_t time_mode;
    uint8_t temp_format;
    uint8_t temp_digit;
    uint8_t timeout;
    uint16_t alarm_timeout;

/* private state histories */
    QStateHandler hist_Clock;
} Clock_Alarm;

/* public: */
static uint32_t Clock_Alarm_GetCurrentTime(void);
static void Clock_Alarm_UpdateCurrentTime(void);
static void Clock_Alarm_SetCurrentTime(uint32_t new_current_time);

/*
 * Description : Displays current time depending upon the time mode
 * param1: 'me' pointer
 * param2 : row number of the LCD
 * param3: column number of the LCD
 */
static void Clock_Alarm_DisplayCurrentTime(Clock_Alarm * const me, uint8_t row, uint8_t col);
static void Clock_Alarm_DisplayClockSettingTime(Clock_Alarm * const me, uint8_t row, uint8_t col);
extern uint32_t Clock_Alarm_current_time;
extern Clock_Alarm Clock_Alarm_obj;

/* protected: */
static QState Clock_Alarm_initial(Clock_Alarm * const me);
static QState Clock_Alarm_Clock(Clock_Alarm * const me);
static QState Clock_Alarm_Ticking(Clock_Alarm * const me);
static QState Clock_Alarm_Settings(Clock_Alarm * const me);
static QState Clock_Alarm_Clock_Setting(Clock_Alarm * const me);
static QState Clock_Alarm_CS_Hour_D2(Clock_Alarm * const me);
static QState Clock_Alarm_CS_Min_D1(Clock_Alarm * const me);
static QState Clock_Alarm_CS_Min_D2(Clock_Alarm * const me);
static QState Clock_Alarm_CS_Sec_D1(Clock_Alarm * const me);
static QState Clock_Alarm_CS_Sec_D2(Clock_Alarm * const me);
static QState Clock_Alarm_CS_Hour_D1(Clock_Alarm * const me);
static QState Clock_Alarm_CS_Format(Clock_Alarm * const me);
static QState Clock_Alarm_CS_Error(Clock_Alarm * const me);
static QState Clock_Alarm_Error_On(Clock_Alarm * const me);
static QState Clock_Alarm_Error_Off(Clock_Alarm * const me);
static QState Clock_Alarm_Alarm_Setting(Clock_Alarm * const me);
static QState Clock_Alarm_AS_Sec_D1(Clock_Alarm * const me);
static QState Clock_Alarm_AS_Sec_D2(Clock_Alarm * const me);
static QState Clock_Alarm_AS_Format(Clock_Alarm * const me);
static QState Clock_Alarm_AS_Min_D2(Clock_Alarm * const me);
static QState Clock_Alarm_AS_Min_D1(Clock_Alarm * const me);
static QState Clock_Alarm_AS_Hour_D2(Clock_Alarm * const me);
static QState Clock_Alarm_AS_Error(Clock_Alarm * const me);
static QState Clock_Alarm_AS_Err_On(Clock_Alarm * const me);
static QState Clock_Alarm_AS_Error_Off(Clock_Alarm * const me);
static QState Clock_Alarm_AS_Hour_D1(Clock_Alarm * const me);
static QState Clock_Alarm_Alarm_On_Off(Clock_Alarm * const me);
static QState Clock_Alarm_Notify(Clock_Alarm * const me);
static QState Clock_Alarm_Notify_Msg_On(Clock_Alarm * const me);
static QState Clock_Alarm_Notify_Msg_Off(Clock_Alarm * const me);
/*.$enddecl${HSMs::Clock_Alarm} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/* Helper Function Prototypes */
String GetAM_PM( uint32_t time24h );
String IntegerTime_ToString( uint32_t time_ );
uint32_t Convert12H_To_24H( uint32_t time12h, time_format_t am_pm );
uint32_t Convert24H_To_12H( uint32_t time24h );
uint8_t IsTime_NotCorrect( uint32_t time_val, time_format_t format );
void display_write( String str_, uint8_t r, uint8_t c );
void display_cursor_on_blinkon( void );
void display_cursor_off_blinkoff( void );
void display_set_cursor( uint8_t row, uint8_t col );
void display_clear( void );
void display_erase_block( uint8_t row, uint8_t col_start, uint8_t col_stop );

/*.$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*. Check for the minimum required QP version */
#if (QP_VERSION < 690U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpn version 6.9.0 or higher required
#endif
/*.$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${HSMs::Clock_Alarm_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${HSMs::Clock_Alarm_ctor} ...............................................*/
void Clock_Alarm_ctor(void) {
    QHsm_ctor( &Clock_Alarm_obj.super, Q_STATE_CAST(&Clock_Alarm_initial));
}
/*.$enddef${HSMs::Clock_Alarm_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${HSMs::super_ClockAlarm} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${HSMs::super_ClockAlarm} ...............................................*/
QHsm *const super_ClockAlarm = &Clock_Alarm_obj.super;
/*.$enddef${HSMs::super_ClockAlarm} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${HSMs::Clock_Alarm} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${HSMs::Clock_Alarm} ....................................................*/
uint32_t Clock_Alarm_current_time;
Clock_Alarm Clock_Alarm_obj;
/*.${HSMs::Clock_Alarm::GetCurrentTime} ....................................*/
static uint32_t Clock_Alarm_GetCurrentTime(void) {
    uint32_t temp = 0u;
    noInterrupts();
    temp = Clock_Alarm_current_time;
    interrupts();
    return (temp);
}

/*.${HSMs::Clock_Alarm::UpdateCurrentTime} .................................*/
static void Clock_Alarm_UpdateCurrentTime(void) {
    /* this function is called from ISR hence we don't need to disable and enable
    interrupts to update this attribute of the class */
    Clock_Alarm_current_time++;
    /* If maximum value is reached, reset the current time */
    if( Clock_Alarm_current_time >= MAX_TIME )
    {
      Clock_Alarm_current_time = 0u;
    }
}

/*.${HSMs::Clock_Alarm::SetCurrentTime} ....................................*/
static void Clock_Alarm_SetCurrentTime(uint32_t new_current_time) {
    /* current_time is also getting updated in interrupts, hence we can't update
    it directly, it should be an atomic update */
    noInterrupts();
    Clock_Alarm_current_time = new_current_time;
    interrupts();
}


/*
 * Description : Displays current time depending upon the time mode
 * param1: 'me' pointer
 * param2 : row number of the LCD
 * param3: column number of the LCD
 */
/*.${HSMs::Clock_Alarm::DisplayCurrentTime} ................................*/
static void Clock_Alarm_DisplayCurrentTime(Clock_Alarm * const me, uint8_t row, uint8_t col) {
    String time_as_string;
    uint32_t time_;

    /* get the current time */
    uint32_t time24h = Clock_Alarm_GetCurrentTime();
    /* extract sub-second to append later */
    uint8_t ss = time24h % 10U;
    /* convert to number of seconds */
    time24h = Clock_Alarm_GetCurrentTime()/10u;

    if( me->time_mode == TIME_MODE_24H )
    {
      /* already in 24 hour format */
      time_ = time24h;
    }
    else
    {
      time_ = Convert24H_To_12H( time24h );
    }

    /* convert integer time to string in hh:mm:ss format*/
    time_as_string = IntegerTime_ToString( time_ );
    /* concatenate sub-seconds */
    time_as_string.concat('.');
    time_as_string.concat( ss );

    /* if mode is 12H , concatenate  am/pm information */
    if( me->time_mode == TIME_MODE_12H )
    {
      time_as_string.concat(' ');
      time_as_string.concat( GetAM_PM(time24h) );
    }
    /* update display */
    display_write(time_as_string, row, col);
}

/*.${HSMs::Clock_Alarm::DisplayClockSettingTime} ...........................*/
static void Clock_Alarm_DisplayClockSettingTime(Clock_Alarm * const me, uint8_t row, uint8_t col) {
    String time_as_string;

    /* convert time to hh:mm:ss format */
    time_as_string = IntegerTime_ToString( me->temp_time );

    /* concatenate AM/PM information */
    if( me->temp_format != FORMAT_24H )
    {
      time_as_string.concat(' ');
      if( me->temp_format == FORMAT_AM )
      {
        time_as_string.concat("AM ");
      }
      else
      {
        time_as_string.concat("PM ");
      }
    }
    /* update the display */
    display_write( time_as_string, row, col);
}

/*.${HSMs::Clock_Alarm::SM} ................................................*/
static QState Clock_Alarm_initial(Clock_Alarm * const me) {
    /*.${HSMs::Clock_Alarm::SM::initial} */
    /* Set the current time at start-up */
    Clock_Alarm_SetCurrentTime( INITIAL_CURRENT_TIME );
    /* Also set the alarm time at start-up */
    me->alarm_time = INITIAL_ALARM_TIME;
    /* Also set the time-mode */
    me->time_mode = TIME_MODE_12H;
    /* Also set the alarm status to off at start-up */
    me->alarm_status = ALARM_OFF;
    /* state history attributes */
    /* state history attributes */
    me->hist_Clock = Q_STATE_CAST(&Clock_Alarm_Ticking);
    return Q_TRAN(&Clock_Alarm_Ticking);
}
/*.${HSMs::Clock_Alarm::SM::Clock} .........................................*/
static QState Clock_Alarm_Clock(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Clock} */
        case Q_EXIT_SIG: {
            /* save deep history */
            me->hist_Clock = QHsm_state(me);
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::ALARM} */
        case ALARM_SIG: {
            /*.${HSMs::Clock_Alarm::SM::Clock::ALARM::[AlarmIsTriggered?]} */
            if (( me->alarm_status == ALARM_ON && Clock_Alarm_GetCurrentTime()/10 == me->alarm_time )) {
                status_ = Q_TRAN(&Clock_Alarm_Notify);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Clock::Ticking} ................................*/
static QState Clock_Alarm_Ticking(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Clock::Ticking} */
        case Q_ENTRY_SIG: {
            Clock_Alarm_DisplayCurrentTime( me, TICKING_CURR_TIME_ROW, TICKING_CURR_TIME_COL );
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Ticking} */
        case Q_EXIT_SIG: {
            /* Clear the display, while exiting this state */
            display_clear();
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Ticking::SET} */
        case SET_SIG: {
            /* get the current time in temp variable */
            me->temp_time = Clock_Alarm_GetCurrentTime()/10u;
            /* Check if mode is 24h or 12h */
            if( me->time_mode == TIME_MODE_12H )
            {
              /* Check if AM or PM */
              if( GetAM_PM( me->temp_time).equals("AM") )
              {
                me->temp_format = FORMAT_AM;
              }
              else
              {
                me->temp_format = FORMAT_PM;
              }
            }
            else
            {
              me->temp_format = FORMAT_24H;
            }
            status_ = Q_TRAN(&Clock_Alarm_Clock_Setting);
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Ticking::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Clock_Alarm_Alarm_Setting);
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Ticking::TICK} */
        case TICK_SIG: {
            Clock_Alarm_DisplayCurrentTime( me, TICKING_CURR_TIME_ROW, TICKING_CURR_TIME_COL );
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_Clock);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Clock::Settings} ...............................*/
static QState Clock_Alarm_Settings(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings} */
        case Q_EXIT_SIG: {
            /* clear the display, when setting state is exited */
            display_clear();
            /* turn of the display blinking */
            display_cursor_off_blinkoff();
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::OK} */
        case OK_SIG: {


            status_ = Q_TRAN(&Clock_Alarm_Ticking);
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::ABRT} */
        case ABRT_SIG: {
            status_ = Q_TRAN(&Clock_Alarm_Ticking);
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_Clock);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting} ................*/
static QState Clock_Alarm_Clock_Setting(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting} */
        case Q_ENTRY_SIG: {
            Clock_Alarm_DisplayClockSettingTime( me, CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_COL);
            /* turn on the blinking on the cursor */
            display_cursor_on_blinkon();
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Clock_Alarm_CS_Hour_D1);
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::OK} */
        case OK_SIG: {
            if( me->temp_format != FORMAT_24H )
            {
              me->temp_time = Convert12H_To_24H( me->temp_time, (time_format_t)(me->temp_format));
              me->time_mode = TIME_MODE_12H;
            }
            else
            {
              me->time_mode = TIME_MODE_24H;
            }

            me->temp_time *= 10ul;
            Clock_Alarm_SetCurrentTime( me->temp_time);
            /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::OK::[AlwaysFalse]} */
            if (0) {
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_Settings);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Hour_D2} ....*/
static QState Clock_Alarm_CS_Hour_D2(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Hour_D2} */
        case Q_ENTRY_SIG: {
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_HOUR_D2_COL);
            /* extract digit-2 of the temp time */
            me->temp_digit = DIGIT2( GET_HOUR(me->temp_time) );
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Hour_D2::SET} */
        case SET_SIG: {
            /* increment the temp digit */
            me->temp_digit++;
            /* Digit-1 value of hour digit can vary between 0, 1 ... 9 */
            me->temp_digit %= 10u;
            /* now we have to update this value in temp_time variable*/
            /* for this we have to first delete the existing time and then add this digit information*/
            me->temp_time -= DIGIT2( GET_HOUR(me->temp_time) ) * 3600ul;
            me->temp_time += (me->temp_digit) * 3600ul;

            /* display this updated value on display */
            /* NOTE: column information should be original because here we are displaying the complete time */
            Clock_Alarm_DisplayClockSettingTime( me, CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_COL);
            /* reset the cursor back to the same position */
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_HOUR_D2_COL);

            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Hour_D2::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Clock_Alarm_CS_Min_D1);
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_Clock_Setting);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Min_D1} .....*/
static QState Clock_Alarm_CS_Min_D1(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Min_D1} */
        case Q_ENTRY_SIG: {
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_MIN_D1_COL);
            /* extract digit-1 of the temp time */
            me->temp_digit = DIGIT1( GET_MIN(me->temp_time) );
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Min_D1::SET} */
        case SET_SIG: {
            /* increment the temp digit */
            me->temp_digit++;
            /* Digit-1 value of minute digit can vary between 0, 1...5 */
            me->temp_digit %= 6u;
            /* now we have to update this value in temp_time variable*/
            /* for this we have to first delete the existing time and then add this digit information*/
            me->temp_time -= DIGIT1( GET_MIN(me->temp_time) ) * 10ul * 60ul;
            me->temp_time += (me->temp_digit * 10ul) * 60ul;

            /* display this updated value on display */
            /* NOTE: column information should be original because here we are displaying the complete time */
            Clock_Alarm_DisplayClockSettingTime( me, CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_COL);
            /* reset the cursor back to the same position */
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_MIN_D1_COL);
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Min_D1::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Clock_Alarm_CS_Min_D2);
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_Clock_Setting);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Min_D2} .....*/
static QState Clock_Alarm_CS_Min_D2(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Min_D2} */
        case Q_ENTRY_SIG: {
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_MIN_D2_COL);
            /* extract digit-2 of the temp time */
            me->temp_digit = DIGIT2( GET_MIN(me->temp_time) );
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Min_D2::SET} */
        case SET_SIG: {
            /* increment the temp digit */
            me->temp_digit++;
            /* Digit-1 value of minute digit can vary between 0, 1...9 */
            me->temp_digit %= 10u;
            /* now we have to update this value in temp_time variable*/
            /* for this we have to first delete the existing time and then add this digit information*/
            me->temp_time -= DIGIT2( GET_MIN(me->temp_time) ) * 60ul;
            me->temp_time += (me->temp_digit) * 60ul;

            /* display this updated value on display */
            /* NOTE: column information should be original because here we are displaying the complete time */
            Clock_Alarm_DisplayClockSettingTime( me, CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_COL);
            /* reset the cursor back to the same position */
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_MIN_D2_COL);
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Min_D2::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Clock_Alarm_CS_Sec_D1);
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_Clock_Setting);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Sec_D1} .....*/
static QState Clock_Alarm_CS_Sec_D1(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Sec_D1} */
        case Q_ENTRY_SIG: {
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_SEC_D1_COL);
            /* extract digit-1 of the temp time */
            me->temp_digit = DIGIT1( GET_SEC(me->temp_time) );
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Sec_D1::SET} */
        case SET_SIG: {
            /* increment the temp digit */
            me->temp_digit++;
            /* Digit-1 value of second digit can vary between 0, 1...5 */
            me->temp_digit %= 6u;
            /* now we have to update this value in temp_time variable*/
            /* for this we have to first delete the existing time and then add this digit information*/
            me->temp_time -= DIGIT1( GET_SEC(me->temp_time) ) * 10ul;
            me->temp_time += (me->temp_digit * 10ul);

            /* display this updated value on display */
            /* NOTE: column information should be original because here we are displaying the complete time */
            Clock_Alarm_DisplayClockSettingTime( me, CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_COL);
            /* reset the cursor back to the same position */
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_SEC_D1_COL);

            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Sec_D1::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Clock_Alarm_CS_Sec_D2);
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_Clock_Setting);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Sec_D2} .....*/
static QState Clock_Alarm_CS_Sec_D2(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Sec_D2} */
        case Q_ENTRY_SIG: {
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_SEC_D2_COL);
            /* extract digit-2 of the temp time */
            me->temp_digit = DIGIT2( GET_SEC(me->temp_time) );
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Sec_D2::SET} */
        case SET_SIG: {
            /* increment the temp digit */
            me->temp_digit++;
            /* Digit-1 value of minute digit can vary between 0, 1...9 */
            me->temp_digit %= 10u;
            /* now we have to update this value in temp_time variable*/
            /* for this we have to first delete the existing time and then add this digit information*/
            me->temp_time -= DIGIT2( GET_SEC(me->temp_time) );
            me->temp_time += (me->temp_digit);

            /* display this updated value on display */
            Clock_Alarm_DisplayClockSettingTime( me, CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_SEC_D2_COL);
            /* reset the cursor back to the same position */
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_SEC_D2_COL);
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Sec_D2::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Clock_Alarm_CS_Format);
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_Clock_Setting);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Hour_D1} ....*/
static QState Clock_Alarm_CS_Hour_D1(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Hour_D1} */
        case Q_ENTRY_SIG: {
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_HOUR_D1_COL);
            /* extract digit-1 of the temp time */
            me->temp_digit = DIGIT1( GET_HOUR(me->temp_time) );
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Hour_D1::SET} */
        case SET_SIG: {
            /* increment the temp digit */
            me->temp_digit++;
            /* Digit-1 value of hour digit can vary between 0, 1 and 2 */
            me->temp_digit %= 3u;
            /* now we have to update this value in temp_time variable*/
            /* for this we have to first delete the existing time and then add this digit information*/
            me->temp_time -= DIGIT1( GET_HOUR(me->temp_time) ) * 10ul * 3600ul;
            me->temp_time += (me->temp_digit * 10ul) * 3600ul;

            /* display this updated value on display */
            Clock_Alarm_DisplayClockSettingTime( me, CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_HOUR_D1_COL);
            /* reset the cursor back to the same position */
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_HOUR_D1_COL);

            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Hour_D1::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Clock_Alarm_CS_Hour_D2);
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_Clock_Setting);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Format} .....*/
static QState Clock_Alarm_CS_Format(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Format} */
        case Q_ENTRY_SIG: {
            String msg[3] = { "24H", "AM ", "PM " };
            /* Set the cursor */
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_FMT_COL );
            /* update the format on lcd */
            display_write( msg[me->temp_format], CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_FMT_COL );
            /* set the cursor again to orignal position */
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_FMT_COL );
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Format::SET} */
        case SET_SIG: {
            String msg;
            if( me->temp_format == FORMAT_24H )
            {
              me->temp_format = FORMAT_AM;
              msg = "AM ";
            }
            else if( me->temp_format == FORMAT_AM )
            {
              me->temp_format = FORMAT_PM;
              msg = "PM ";
            }
            else if( me->temp_format == FORMAT_PM )
            {
              me->temp_format = FORMAT_24H;
              msg = "24H";
            }
            /* update the format on lcd */
            display_write( msg, CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_FMT_COL );
            /* set the cursor again to orignal position */
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_FMT_COL );
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Format::OK} */
        case OK_SIG: {
            /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Format::OK::[TimeIsCorrect?]} */
            if (IsTime_NotCorrect( me->temp_time, (time_format_t)me->temp_format )) {
                status_ = Q_TRAN(&Clock_Alarm_CS_Error);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_Clock_Setting);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Error} ......*/
static QState Clock_Alarm_CS_Error(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Error} */
        case Q_ENTRY_SIG: {
            display_cursor_off_blinkoff();
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Error} */
        case Q_EXIT_SIG: {
            /* Erase the error message */
            display_erase_block( CLOCK_SETTING_ERR_MSG_ROW, CLOCK_SETTING_ERR_MSG_COL, CLOCK_SETTING_ERR_MSG_COL_END);
            me->timeout = 0u;
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Error::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Clock_Alarm_Error_On);
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Error::SET} */
        case SET_SIG: {
            /* turn on the blinking on the cursor */
            display_cursor_on_blinkon();
            status_ = Q_TRAN(&Clock_Alarm_Clock_Setting);
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Error::OK} */
        case OK_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_Clock_Setting);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Error::Error_On} */
static QState Clock_Alarm_Error_On(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Error::Error_On} */
        case Q_ENTRY_SIG: {
            display_write( "Error!", CLOCK_SETTING_ERR_MSG_ROW, CLOCK_SETTING_ERR_MSG_COL);
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Error::Error_On::TICK} */
        case TICK_SIG: {
            /* Increment the timeout variable */
            me->timeout++;
            /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Error::Error_On::TICK::[Timeout?]} */
            if (me->timeout == 10) {
                /* reset the timeout counter */
                me->timeout = 0u;
                status_ = Q_TRAN(&Clock_Alarm_Error_Off);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_CS_Error);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Error::Error_Off} */
static QState Clock_Alarm_Error_Off(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Error::Error_Off} */
        case Q_ENTRY_SIG: {
            /* Erase the error message */
            display_erase_block( CLOCK_SETTING_ERR_MSG_ROW, CLOCK_SETTING_ERR_MSG_COL, CLOCK_SETTING_ERR_MSG_COL_END);
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Error::Error_Off::TICK} */
        case TICK_SIG: {
            me->timeout++;
            /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Clock_Setting::CS_Error::Error_Off::TICK::[Timeout?]} */
            if (me->timeout == 10) {
                /* reset the timeout counter */
                me->timeout = 0u;
                status_ = Q_TRAN(&Clock_Alarm_Error_On);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_CS_Error);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting} ................*/
static QState Clock_Alarm_Alarm_Setting(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting} */
        case Q_ENTRY_SIG: {
            Clock_Alarm_DisplayClockSettingTime(me,CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_COL);
            display_cursor_on_blinkon();
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Clock_Alarm_AS_Hour_D1);
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::OK} */
        case OK_SIG: {
            me->alarm_status = me->temp_digit;
            if(me->temp_format != FORMAT_24H)
            {
              me->temp_time = Convert12H_To_24H( me->temp_time, (time_format_t)me->temp_format);
            }
            me->alarm_time = me->temp_time;
            /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::OK::[0]} */
            if (0) {
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::TICK} */
        case TICK_SIG: {
            /* Display Current Time */
            Clock_Alarm_DisplayCurrentTime( me, ALARM_SETTING_CURR_TIME_ROW, ALARM_SETTING_CURR_TIME_COL );
            if( QHsm_state(me) != Q_STATE_CAST(&Clock_Alarm_Alarm_On_Off))
            {
              Clock_Alarm_DisplayClockSettingTime(me, CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_COL);
            }

            if( QHsm_state(me) == Q_STATE_CAST(&Clock_Alarm_AS_Hour_D1))
            {
              display_set_cursor( CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_HOUR_D1_COL);
            }
            else if( QHsm_state(me) == Q_STATE_CAST(&Clock_Alarm_AS_Hour_D2))
            {
              display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_HOUR_D2_COL);
            }
            else if( QHsm_state(me) == Q_STATE_CAST(&Clock_Alarm_AS_Min_D1))
            {
              display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_MIN_D1_COL);
            }
            else if( QHsm_state(me) == Q_STATE_CAST(&Clock_Alarm_AS_Min_D2))
            {
              display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_MIN_D2_COL);
            }
            else if( QHsm_state(me) == Q_STATE_CAST(&Clock_Alarm_AS_Sec_D1))
            {
              display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_SEC_D1_COL);
            }
            else if( QHsm_state(me) == Q_STATE_CAST(&Clock_Alarm_AS_Sec_D2))
            {
              display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_SEC_D2_COL);
            }
            else if( QHsm_state(me) == Q_STATE_CAST(&Clock_Alarm_AS_Format))
            {
              display_set_cursor(CLOCK_SETTING_TIME_ROW,CLOCK_SETTING_TIME_FMT_COL);
            }
            else if( QHsm_state(me) == Q_STATE_CAST(&Clock_Alarm_Alarm_On_Off))
            {
              display_set_cursor(CLOCK_SETTING_TIME_ROW,ALARM_SETTING_STATUS_COL);
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_Settings);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Sec_D1} .....*/
static QState Clock_Alarm_AS_Sec_D1(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Sec_D1} */
        case Q_ENTRY_SIG: {
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_SEC_D1_COL);
            /* extract digit-1 of the temp time */
            me->temp_digit = DIGIT1( GET_SEC(me->temp_time) );
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Sec_D1::SET} */
        case SET_SIG: {
            /* increment the temp digit */
            me->temp_digit++;
            /* Digit-1 value of second digit can vary between 0, 1...5 */
            me->temp_digit %= 6u;
            /* now we have to update this value in temp_time variable*/
            /* for this we have to first delete the existing time and then add this digit information*/
            me->temp_time -= DIGIT1( GET_SEC(me->temp_time) ) * 10ul;
            me->temp_time += (me->temp_digit * 10ul);

            /* display this updated value on display */
            /* NOTE: column information should be original because here we are displaying the complete time */
            Clock_Alarm_DisplayClockSettingTime( me, CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_COL);
            /* reset the cursor back to the same position */
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_SEC_D1_COL);

            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Sec_D1::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Clock_Alarm_AS_Sec_D2);
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_Alarm_Setting);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Sec_D2} .....*/
static QState Clock_Alarm_AS_Sec_D2(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Sec_D2} */
        case Q_ENTRY_SIG: {
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_SEC_D2_COL);
            /* extract digit-2 of the temp time */
            me->temp_digit = DIGIT2( GET_SEC(me->temp_time) );
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Sec_D2::SET} */
        case SET_SIG: {
            /* increment the temp digit */
            me->temp_digit++;
            /* Digit-1 value of minute digit can vary between 0, 1...9 */
            me->temp_digit %= 10u;
            /* now we have to update this value in temp_time variable*/
            /* for this we have to first delete the existing time and then add this digit information*/
            me->temp_time -= DIGIT2( GET_SEC(me->temp_time) );
            me->temp_time += (me->temp_digit);

            /* display this updated value on display */
            Clock_Alarm_DisplayClockSettingTime( me, CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_SEC_D2_COL);
            /* reset the cursor back to the same position */
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_SEC_D2_COL);
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Sec_D2::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Clock_Alarm_AS_Format);
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_Alarm_Setting);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Format} .....*/
static QState Clock_Alarm_AS_Format(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Format} */
        case Q_ENTRY_SIG: {
            String msg[3] = { "24H", "AM ", "PM " };
            /* Set the cursor */
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_FMT_COL );
            /* update the format on lcd */
            display_write( msg[me->temp_format], CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_FMT_COL );
            /* set the cursor again to orignal position */
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_FMT_COL );
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Format::SET} */
        case SET_SIG: {
            String msg;
            if( me->temp_format == FORMAT_24H )
            {
              me->temp_format = FORMAT_AM;
              msg = "AM ";
            }
            else if( me->temp_format == FORMAT_AM )
            {
              me->temp_format = FORMAT_PM;
              msg = "PM ";
            }
            else if( me->temp_format == FORMAT_PM )
            {
              me->temp_format = FORMAT_24H;
              msg = "24H";
            }
            /* update the format on lcd */
            display_write( msg, CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_FMT_COL );
            /* set the cursor again to orignal position */
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_FMT_COL );
            Serial.println("AS Format SET Signal");
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Format::OK} */
        case OK_SIG: {
            /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Format::OK::[TimeIsCorrect?]} */
            if (IsTime_NotCorrect( me->temp_time, (time_format_t)me->temp_format )) {
                status_ = Q_TRAN(&Clock_Alarm_AS_Error);
            }
            /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Format::OK::[else]} */
            else {
                status_ = Q_TRAN(&Clock_Alarm_Alarm_On_Off);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_Alarm_Setting);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Min_D2} .....*/
static QState Clock_Alarm_AS_Min_D2(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Min_D2} */
        case Q_ENTRY_SIG: {
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_MIN_D2_COL);
            /* extract digit-2 of the temp time */
            me->temp_digit = DIGIT2( GET_MIN(me->temp_time) );
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Min_D2::SET} */
        case SET_SIG: {
            /* increment the temp digit */
            me->temp_digit++;
            /* Digit-1 value of minute digit can vary between 0, 1...9 */
            me->temp_digit %= 10u;
            /* now we have to update this value in temp_time variable*/
            /* for this we have to first delete the existing time and then add this digit information*/
            me->temp_time -= DIGIT2( GET_MIN(me->temp_time) ) * 60ul;
            me->temp_time += (me->temp_digit) * 60ul;

            /* display this updated value on display */
            /* NOTE: column information should be original because here we are displaying the complete time */
            Clock_Alarm_DisplayClockSettingTime( me, CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_COL);
            /* reset the cursor back to the same position */
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_MIN_D2_COL);
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Min_D2::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Clock_Alarm_AS_Sec_D1);
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_Alarm_Setting);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Min_D1} .....*/
static QState Clock_Alarm_AS_Min_D1(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Min_D1} */
        case Q_ENTRY_SIG: {
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_MIN_D1_COL);
            /* extract digit-1 of the temp time */
            me->temp_digit = DIGIT1( GET_MIN(me->temp_time) );
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Min_D1::SET} */
        case SET_SIG: {
            /* increment the temp digit */
            me->temp_digit++;
            /* Digit-1 value of minute digit can vary between 0, 1...5 */
            me->temp_digit %= 6u;
            /* now we have to update this value in temp_time variable*/
            /* for this we have to first delete the existing time and then add this digit information*/
            me->temp_time -= DIGIT1( GET_MIN(me->temp_time) ) * 10ul * 60ul;
            me->temp_time += (me->temp_digit * 10ul) * 60ul;

            /* display this updated value on display */
            /* NOTE: column information should be original because here we are displaying the complete time */
            Clock_Alarm_DisplayClockSettingTime( me, CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_COL);
            /* reset the cursor back to the same position */
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_MIN_D1_COL);

            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Min_D1::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Clock_Alarm_AS_Min_D2);
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_Alarm_Setting);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Hour_D2} ....*/
static QState Clock_Alarm_AS_Hour_D2(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Hour_D2} */
        case Q_ENTRY_SIG: {
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_HOUR_D2_COL);
            /* extract digit-2 of the temp time */
            me->temp_digit = DIGIT2( GET_HOUR(me->temp_time) );
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Hour_D2::SET} */
        case SET_SIG: {
            /* increment the temp digit */
            me->temp_digit++;
            /* Digit-1 value of hour digit can vary between 0, 1 ... 9 */
            me->temp_digit %= 10u;
            /* now we have to update this value in temp_time variable*/
            /* for this we have to first delete the existing time and then add this digit information*/
            me->temp_time -= DIGIT2( GET_HOUR(me->temp_time) ) * 3600ul;
            me->temp_time += (me->temp_digit) * 3600ul;

            /* display this updated value on display */
            /* NOTE: column information should be original because here we are displaying the complete time */
            Clock_Alarm_DisplayClockSettingTime( me, CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_COL);
            /* reset the cursor back to the same position */
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_HOUR_D2_COL);
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Hour_D2::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Clock_Alarm_AS_Min_D1);
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_Alarm_Setting);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Error} ......*/
static QState Clock_Alarm_AS_Error(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Error} */
        case Q_ENTRY_SIG: {
            display_cursor_off_blinkoff();
            display_erase_block( ALARM_SETTING_CURR_TIME_ROW, 0, 15);
            me->timeout = 0;
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Error} */
        case Q_EXIT_SIG: {
            display_erase_block( CLOCK_SETTING_ERR_MSG_ROW, CLOCK_SETTING_ERR_MSG_COL,CLOCK_SETTING_ERR_MSG_COL_END);
            me->timeout = 0UL;
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Error::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Clock_Alarm_AS_Err_On);
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_Alarm_Setting);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Error::AS_Err_On} */
static QState Clock_Alarm_AS_Err_On(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Error::AS_Err_On} */
        case Q_ENTRY_SIG: {
            display_write( "Error!", CLOCK_SETTING_ERR_MSG_ROW, CLOCK_SETTING_ERR_MSG_COL);
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Error::AS_Err_On::TICK} */
        case TICK_SIG: {
            /* Increment the timeout variable */
            me->timeout++;
            /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Error::AS_Err_On::TICK::[Timeout?]} */
            if (me->timeout == 10) {
                /* reset the timeout counter */
                me->timeout = 0u;
                status_ = Q_TRAN(&Clock_Alarm_AS_Error_Off);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_AS_Error);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Error::AS_Error_Off} */
static QState Clock_Alarm_AS_Error_Off(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Error::AS_Error_Off} */
        case Q_ENTRY_SIG: {
            /* Erase the error message */
            display_erase_block( CLOCK_SETTING_ERR_MSG_ROW, CLOCK_SETTING_ERR_MSG_COL, CLOCK_SETTING_ERR_MSG_COL_END);
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Error::AS_Error_Off::TICK} */
        case TICK_SIG: {
            me->timeout++;
            /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Error::AS_Error_Off::TICK::[me->timeout==10]} */
            if (me->timeout == 10) {
                /* reset the timeout counter */
                me->timeout = 0u;
                status_ = Q_TRAN(&Clock_Alarm_AS_Err_On);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_AS_Error);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Hour_D1} ....*/
static QState Clock_Alarm_AS_Hour_D1(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Hour_D1} */
        case Q_ENTRY_SIG: {
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_HOUR_D1_COL);
            me->temp_digit = DIGIT1( GET_HOUR(me->temp_time) );
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Hour_D1::SET} */
        case SET_SIG: {
            /* increment the temp digit */
            me->temp_digit++;
            /* Digit-1 value of hour digit can vary between 0, 1 and 2 */
            me->temp_digit %= 3u;
            /* now we have to update this value in temp_time variable*/
            /* for this we have to first delete the existing time and then add this digit information*/
            me->temp_time -= DIGIT1( GET_HOUR(me->temp_time) ) * 10ul * 3600ul;
            me->temp_time += (me->temp_digit * 10ul) * 3600ul;

            /* display this updated value on display */
            Clock_Alarm_DisplayClockSettingTime( me, CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_HOUR_D1_COL);
            /* reset the cursor back to the same position */
            display_set_cursor( CLOCK_SETTING_TIME_ROW, CLOCK_SETTING_TIME_HOUR_D1_COL);
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::AS_Hour_D1::OK} */
        case OK_SIG: {
            status_ = Q_TRAN(&Clock_Alarm_AS_Hour_D2);
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_Alarm_Setting);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::Alarm_On_Off} ..*/
static QState Clock_Alarm_Alarm_On_Off(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::Alarm_On_Off} */
        case Q_ENTRY_SIG: {
            me->temp_digit = 0u;
            display_erase_block( ALARM_SETTING_STATUS_ROW, 0, 15);
            display_write( "ALARM OFF", ALARM_SETTING_STATUS_ROW, ALARM_SETTING_STATUS_COL);
            display_set_cursor(ALARM_SETTING_STATUS_ROW,ALARM_SETTING_STATUS_COL);
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Clock::Settings::Alarm_Setting::Alarm_On_Off::SET} */
        case SET_SIG: {
            if( me->temp_digit )
            {
              display_write("ALARM OFF", ALARM_SETTING_STATUS_ROW, ALARM_SETTING_STATUS_COL);
              me->temp_digit = 0;
            }
            else
            {
              display_write("ALARM ON ", ALARM_SETTING_STATUS_ROW, ALARM_SETTING_STATUS_COL);
              me->temp_digit = 1;
            }
            display_set_cursor( ALARM_SETTING_STATUS_ROW, ALARM_SETTING_STATUS_COL);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_Alarm_Setting);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Notify} ........................................*/
static QState Clock_Alarm_Notify(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Notify} */
        case Q_ENTRY_SIG: {
            me->timeout = 0;
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Notify} */
        case Q_EXIT_SIG: {
            display_clear();
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Notify::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Clock_Alarm_Notify_Msg_On);
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Notify::OK} */
        case OK_SIG: {
            status_ = Q_TRAN_HIST(me->hist_Clock);
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Notify::TICK} */
        case TICK_SIG: {
            Clock_Alarm_DisplayCurrentTime( me, ALARM_SETTING_CURR_TIME_ROW, ALARM_SETTING_CURR_TIME_COL);
            /*.${HSMs::Clock_Alarm::SM::Notify::TICK::[AlarmTimeout?]} */
            if (++me->alarm_timeout == 200u) {
                me->alarm_timeout = 0u;
                status_ = Q_TRAN(&Clock_Alarm_Ticking);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Notify::Notify_Msg_On} .........................*/
static QState Clock_Alarm_Notify_Msg_On(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Notify::Notify_Msg_On} */
        case Q_ENTRY_SIG: {
            display_write( "*ALARM*", ALARM_NOTIFY_MSG_ROW, ALARM_NOTIFY_MSG_COL);
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Notify::Notify_Msg_On::TICK} */
        case TICK_SIG: {
            me->timeout++;
            /*.${HSMs::Clock_Alarm::SM::Notify::Notify_Msg_On::TICK::[Timeout?]} */
            if (me->timeout == 10) {
                me->timeout = 0;
                status_ = Q_TRAN(&Clock_Alarm_Notify_Msg_Off);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_Notify);
            break;
        }
    }
    return status_;
}
/*.${HSMs::Clock_Alarm::SM::Notify::Notify_Msg_Off} ........................*/
static QState Clock_Alarm_Notify_Msg_Off(Clock_Alarm * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /*.${HSMs::Clock_Alarm::SM::Notify::Notify_Msg_Off} */
        case Q_ENTRY_SIG: {
            display_erase_block( ALARM_NOTIFY_MSG_ROW, ALARM_NOTIFY_MSG_COL, 10);
            status_ = Q_HANDLED();
            break;
        }
        /*.${HSMs::Clock_Alarm::SM::Notify::Notify_Msg_Off::TICK} */
        case TICK_SIG: {
            me->timeout++;
            /*.${HSMs::Clock_Alarm::SM::Notify::Notify_Msg_Off::TICK::[Timeout?]} */
            if (me->timeout == 10) {
                me->timeout = 0;
                status_ = Q_TRAN(&Clock_Alarm_Notify_Msg_On);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_Alarm_Notify);
            break;
        }
    }
    return status_;
}
/*.$enddef${HSMs::Clock_Alarm} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*
 * Description : Decodes AM/PM information from given time in 24H format
 * param1: Integer time in 24H format
 * return : A string value("AM" or "PM")
 */
String GetAM_PM( uint32_t time24h )
{
    String am_pm;
    uint8_t hour = GET_HOUR( time24h );
    if(hour == 0U)
    {
        am_pm = "AM ";
    }
    else if( hour > 12U)
    {
        am_pm = "PM ";
    }
    else if ( hour == 12U )
    {
        am_pm = "PM";
    }
    else
    {
        am_pm = "AM";
    }

    return am_pm;
}

/*
 * Description: converts an 'integer' time to 'String' time
 * param1 : time represented in terms of number of seconds
 * return : time as 'String' value in the format HH:MM:SS
 */
String IntegerTime_ToString( uint32_t time_ )
{
    uint8_t hour, minute, second;
    char buffer[10];       // 00:00:00+null
    hour   = GET_HOUR(time_);   /* Extract how many hours the 'time_' represent */
    minute = GET_MIN(time_);    /* Extract how many minutes the 'time_' represent */
    second = GET_SEC(time_);	/* Extract how many seconds the 'time_' represent */
    sprintf( buffer, "%02d:%02d:%02d", hour, minute, second );
    return (String)buffer;
}

/*
 * Description: Converts given integer time in 12H format to integer time 24H format
 * param1 : Integer time in 12H format
 * param2 : time format of type time_format_t
 * return : Integer time in 24H format
 */
uint32_t Convert12H_To_24H( uint32_t time12h, time_format_t am_pm )
{
    uint8_t hour;
    uint32_t time24h;
    hour = GET_HOUR( time12h );
    if(am_pm == FORMAT_AM )
    {
        time24h = (hour == 12) ? (time12h-(12UL * 3600UL)) : time12h;
    }
    else
    {
        time24h = (hour == 12)? time12h : (time12h +(12UL * 3600UL));
    }
    return time24h;
}

/*
 * Description: Converts given integer time in 24H format to integer time 12H format
 * param1 : Integer time in 24H format
 * return : Integer time in 12H format
 */
uint32_t Convert24H_To_12H( uint32_t time24h )
{
    uint8_t hour;
    uint32_t time12h;
    hour = GET_HOUR(time24h);

    if(hour == 0)
    {
        time12h = time24h + (12UL * 3600UL);
    }
    else
    {
        if( (hour < 12UL) || (hour == 12UL) )
        {
            return time24h;
        }
        else
        {
            time12h = time24h - (12UL * 3600UL);
        }
    }
    return time12h;
}

uint8_t IsTime_NotCorrect( uint32_t time_val, time_format_t format )
{
  uint8_t status = 0x00;
  uint8_t hour = GET_HOUR( time_val );

  if( (hour>23) || ( (hour>12||hour==0) && (format!=FORMAT_24H) ) )
  {
    status = 0x01;
  }

  return status;
}

/*
 * Description: Writes a message to the LCD at given row and column number
 * param1 : Message to write in 'String' format
 * param2 : row number of the LCD
 * param2 : column number of the LCD
 */
void display_write( String str_, uint8_t r, uint8_t c )
{
    lcd_set_cursor( c,r );
    lcd_print_string( str_ );
}

void display_cursor_on_blinkon( void )
{
  lcd_cursor_show();
  lcd_cursor_blink();
}

void display_cursor_off_blinkoff( void )
{
  lcd_cursor_off();
  lcd_cursor_blinkoff();
}

void display_set_cursor( uint8_t row, uint8_t col )
{
  lcd_set_cursor( col, row);
}

void display_clear( void )
{
  lcd_clear();
}

void display_erase_block( uint8_t row, uint8_t col_start, uint8_t col_stop )
{
  uint8_t len = col_stop - col_start;
  do
  {
    lcd_set_cursor(col_start, row);
    col_start++;
    lcd_print_char(' ');
  } while (len--);
}

ISR( TIMER1_COMPA_vect )
{
  Clock_Alarm_UpdateCurrentTime();
}
